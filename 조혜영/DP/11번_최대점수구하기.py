

#¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨
#      11번. 최대 점수 구하기  
#
#     dy[j]: j분 동안 얻을 수 있는 최대 점수 / 문제는 한번만 풀 수 있음
#
#    * 중복 불가  
#       - sol1) 2차원 배열로 구현하여 다음 원소 추가시 이전에 해당 원소 없이 
#               최대로 구해졌던 dy를 bottom-up으로 참조!
#       - sol2) 뒤에서부터 dy배열을 채워서 중복 방지
#…………………………………………………………………………………………………………………………………………………………………………………………

# n개의 문제의 종류 / m분 동안 얻을 수 있는 최대 점수 
n, m=map(int, input().split())

# dp배열 선언 (dy[j]: j분 동안 얻을 수 있는 최대 점수)
dy=[0]*(m+1);

for i in range(n): # 총 n개의 문제 경우의 수 다 고려할때까지 
    
    ps, pt=map(int, input().split()) # ps: 문제의 배점/ pt: 소요되는 시간
    
    ''' 
    <뒤에서부터 dy배열을 채우면 똑같은 문제 중복 방지 가능!!>
    - 우선 j시간 동안 해당 문제를 풀었다고 가정하여 dy[j-pt]의 최대값에 + ps를 해주게 되는데 
      이때 bottom-up 방식대로 남은 시간이 가진 최대의 배점을 dy[j-pt]방식대로 참조할때 
      아직 순회하지 않은 앞부분의 dy는 해당 문제가 포함되지 않은 최대의 점수로 dy가 이뤄졌으니까 중복이 발생되지 않음
    '''
    for j in range(m, pt-1, -1): # 뒤에서부터 dy를 update한다.
        dy[j]=max(dy[j], dy[j-pt]+ps)
print(dy[m])



# solution 2)
# : 2차원 배열을 이용하여 dy[i]가 update되는 과정을 다 기록하는것임 
# 그렇게 해서 해당 원소가 포함되지 않았을때의 최대 값이 dy에 기록됐으니까 
# 기존의 dy[i]참조하여 update하는 방식에서 참조하는 dy[i]의 
# 행은 풀었다고 추가시킬 문제/ 열은 주어진 시간 

