#¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨
#                  9번. 가방 문제  (중복 허용)
#
#   dy[j]: 가방이 j무게일때 가질 수 있는 보석의 최대 가치
#…………………………………………………………………………………………………………………………………………………………………………………………

n, m=map(int, input().split()) # n: 보석의 종류/ m: 가방의 최대 무게 
# dp배열 선언 (dy[j]: 가방이 j무게일때 가질 수 있는 보석의 최대 가치)
dy=[0]*(m+1);


for i in range(n): # 각 보석(n)별로 dy를 순회하면서 가치를 update시킨다.
    w, v=map(int, input().split()) # 해당 보석의 무게와 가치
    
    '''
    각 보석의 종류별로 하나씩 dy를 순회하면서 가치를 update시킨다.
    이때 update할 dy의 범위는 선택된 보석의 무게보다 큰 값의 범위(j: w ~ m+1)임 
    (선택된 보석의 무게보다 작은 가방의 무게j에는 해당 보석은 들어갈 수 없으니까)
    
    j무게에서 해당 보석을 포함시켜서 update한 가치(dy[j-w]+v)와 
    기존의 가치(dy[j])를 비교하여 더 큰 가치로 dy[j]를 update를 하는데 
    이때 bottom-up의 방식을 이용하여 해당 보석이 가방에 들어갔으므로 남은 무게는 dy[j-w]에서
    최대가치를 확인하고 거기에 해당 보석의 가치(v)를 덧붙인다.
    '''
    for j in range(w, m+1):
        dy[j]=max(dy[j], dy[j-w]+v) 
print(dy[m])








#¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨
#             10번. 동전 교환  (중복 허용)
#
#    dy[j]: j원을 거슬러주는데 사용된 동전의 최소 개수
#…………………………………………………………………………………………………………………………………………………………………………………………

# n: 동전의 가짓수/ coin: 동전의 정보/ m: 거슬러줘야할 돈 
n=int(input()) 
coin=list(map(int, input().split())) 
m=int(input()) 

# dp배열 선언 (dy[j]: j원을 거슬러주는데 사용된 동전의 최소 개수)
dy=[1000]*(m+1);
dy[0]=0

# 동전의 종류(n개)별로 dy를 순회하면서 최소 개수를 update시킨다.
for i in range(n): 

    for j in range(coin[i], m+1):  # 돌려줘야할 거스름돈(j)이 해당 동전보다는 큰 경우만 update  
        dy[j]=min(dy[j], dy[j-coin[i]]+1) # 최소값을 선택하는거니까 min
print(dy[m])





