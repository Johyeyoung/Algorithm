import sys
sys.stdin = open("input.txt", 'r')    



# ----------------------------------------------------------------------------------------------------------
# ----------------------------------------------------------------------------------------------------------
#                                               BOTTOM - UP
# ----------------------------------------------------------------------------------------------------------
# ----------------------------------------------------------------------------------------------------------
if __name__=="__main__":
    n=int(input())
    arr=[list(map(int, input().split())) for _ in range(n)]  # 맵이 주어지는 부분
    
    
    
    
    # ---------------bottom up용 list 배열 선언하고(최소비용)------------------
    dy=[[0]*n for _ in range(n)]
    dy[0][0]=arr[0][0] # 직관적인 부분(시작부분) 채우고
    
    # --------------for문을 돌면서 목적지 n까지 dy채우기-------------
    # ------------ 올 수 있는 경로가 오직 한가지만 있는 격자점을 먼저 채우고
    for i in range(1, n):
        # build up: 이동하는 방향은 ↓, → 
        dy[0][i]=dy[0][i-1]+arr[0][i] 
        dy[i][0]=dy[i-1][0]+arr[i][0]
    
    # ----------- 해당 격자점으로 올 수 있는 경로가 2가지(→, ↓)인 경우는 최소값에 더해준다
    for i in range(1, n):
        for j in range(1, n):
            dy[i][j]=min(dy[i-1][j], dy[i][j-1])+arr[i][j]
    
    
    
    print(dy[n-1][n-1])

    
    
    
    
    
# ----------------------------------------------------------------------------------------------------------
# ----------------------------------------------------------------------------------------------------------
#                                               TOP - DOWN
# ----------------------------------------------------------------------------------------------------------
# ----------------------------------------------------------------------------------------------------------
def DFS(x, y): # 항상 인덱스만 넣어주기
    
    # 재귀적이지만 이렇게 저장한걸 부를 수 있으니까 DP
    if dy[x][y]>0:
        return dy[x][y] # 매개변수로 들어온 인덱스에 해당하는 값 반환

    # 탈출문        
    if x==0 and y==0:
        return arr[0][0]
    
    
    else:
        # 첫번쨰 열, 첫번쨰 행은 올 수 있는 경로가 하나니까
        if y==0:
            dy[x][y]=DFS(x-1, y)+arr[x][y]
        elif x==0:
            dy[x][y]=DFS(x, y-1)+arr[x][y]
        # 나머지부분은 올 수 있는 경로가 2개라서 최소에서 더해주기
        else:
            dy[x][y]=min(DFS(x-1, y), DFS(x, y-1))+arr[x][y]
        return dy[x][y] # 매개변수로 들어온 인덱스에 해당하는 값 반환


if __name__=="__main__":
    n=int(input())
    arr=[list(map(int, input().split())) for _ in range(n)]
    dy=[[0]*n for _ in range(n)]
    print(DFS(n-1, n-1))
