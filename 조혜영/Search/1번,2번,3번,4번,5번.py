#¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨
#                     1번. 회문 문자열 검사 (1차원 배열)
#            (지점 설정) a[i+dx[k]][j+dy[k] : (i, j)번째 지점의 상하좌우 탐색
#…………………………………………………………………………………………………………………………………………………………………………………………

n=int(input())
for i in range(1, n+1):
    str=input()
    str=str.upper()
    for j in range(len(str)//2): # 하나하나 for문 돌면서 원소
        if str[j]!=str[-1-j]: 
            print("#%d NO" %i)
            break
    else:
        print("#%d YES" %i)
        
        
#-------------문자열 뒤집기 풀이-------------
n=int(input())
for i in range(1, n+1):
    str=input()
    str=str.upper()
    if str == str[::-1]: # 문자열 뒤집기
        print("#%d YES" %i)
    else:
        print("#%d NO" %i)
        

#¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨
#                     2번. 숫자만 추출 (1차원 배열)
#…………………………………………………………………………………………………………………………………………………………………………………………

s=input()
res=0
for x in s:
    if x.isdecimal(): # 문자가 숫자인지 확인
        res=res*10+int(x) # 기존의 숫자를 자릿수 올리기 위해 *10 
print(res)
cnt=0
for i in range(1, res+1):
    if res%i==0:
        cnt+=1
print(cnt)






#¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨
#                     3번. 카드 역배치 (1차원 배열)
#            (지점 설정) a[i+dx[k]][j+dy[k] : (i, j)번째 지점의 상하좌우 탐색
#…………………………………………………………………………………………………………………………………………………………………………………………

a=list(range(21))
for _ in range(10): # 그냥 10번 입력받는거니까 변수없이 for문
    s, e=map(int, input().split()) # 구간의 처음과 끝이 주어짐 이 안에 있는 숫자는 다 교환
    for i in range((e-s+1)//2): # 2~7이면 총 (7-2)+1//2 = 3번
        a[s+i], a[e-i]=a[e-i], a[s+i]  # swap하기
a.pop(0)
for x in a:
    print(x, end=' ')




#¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨
#                 4번. 두 리스트합치기 (1차원 배열)
#    sort는 nlogn이므로 이미 정렬되어있는걸 리스트합쳐서 정렬하지말고 n으로 끝내기
#…………………………………………………………………………………………………………………………………………………………………………………………


n=int(input())
# ----------------2개의 1차원 배열 입력받기------------------
a=list(map(int, input().split()))
m=int(input())
b=list(map(int, input().split()))

p1=p2=0 # 각 배열의 인덱스
c=[]
# 어차피 정렬된 두 배열이 주어지니까 합쳐서 sort하지말고 n만큼 한번만 for문돌기
while p1<n and p2<m: # 두 배열 중 하나가 끝나기 전까지 각각의 앞자리 중 작은걸 리스트에 update
    if a[p1]<b[p2]:
        c.append(a[p1])
        p1+=1
    else:
        c.append(b[p2])
        p2+=1
# 하나의 배열이 다 끝나면 원소가 남은 배열은 슬라이스로 붙여주기
if p1<n:
    c=c+a[p1:]
if p2<m:
    c=c+b[p2:]
for x in c:
    print(x, end=' ')
    
    
#¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨
#                 5. 수의 합 (1차원 배열)
#…………………………………………………………………………………………………………………………………………………………………………………………

n, m=map(int, input().split())
a=list(map(int, input().split()))
lt=0
rt=1
tot=a[0]
cnt=0
while True:
    if tot<m: # 아직 더 더해도됨
        if rt<n: 
            tot+=a[rt]
            rt+=1
        else:
            break
    elif tot==m: # 이제 과거원소버리고 lt +=1
        cnt+=1
        tot-=a[lt]
        lt+=1
    else: # 과거 원소버리기 너무
        tot-=a[lt]
        lt+=1
print(cnt)
