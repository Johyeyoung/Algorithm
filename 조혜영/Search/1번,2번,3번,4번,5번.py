#¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨
#                     1번. 회문 문자열 검사 (1차원 배열)
#            (지점 설정) a[i+dx[k]][j+dy[k] : (i, j)번째 지점의 상하좌우 탐색
#…………………………………………………………………………………………………………………………………………………………………………………………

for i in R:
  if R[i] != R[-1-i]:
    return false
else return true


#¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨
#                     2번. 숫자만 추출 (1차원 배열)
#…………………………………………………………………………………………………………………………………………………………………………………………

s=input()
res=0
for x in s:
    if x.isdecimal(): # 문자가 숫자인지 확인
        res=res*10+int(x) # 기존의 숫자를 자릿수 올리기 위해 *10 
print(res)
cnt=0
for i in range(1, res+1):
    if res%i==0:
        cnt+=1
print(cnt)






#¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨
#                     3번. 카드 역배치 (1차원 배열)
#            (지점 설정) a[i+dx[k]][j+dy[k] : (i, j)번째 지점의 상하좌우 탐색
#…………………………………………………………………………………………………………………………………………………………………………………………

a=list(range(21))
for _ in range(10):
    s, e=map(int, input().split())
    for i in range((e-s+1)//2):
        a[s+i], a[e-i]=a[e-i], a[s+i]
a.pop(0)
for x in a:
    print(x, end=' ')




#¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨
#                 4번. 두 리스트합치기 (1차원 배열)
#    sort는 nlogn이므로 이미 정렬되어있는걸 리스트합쳐서 정렬하지말고 n으로 끝내기
#…………………………………………………………………………………………………………………………………………………………………………………………


n=int(input())
# ----------------2개의 1차원 배열 입력받기------------------
a=list(map(int, input().split()))
m=int(input())
b=list(map(int, input().split()))

p1=p2=0
c=[]
while p1<n and p2<m:
    if a[p1]<b[p2]:
        c.append(a[p1])
        p1+=1
    else:
        c.append(b[p2])
        p2+=1
# 하나의 배열이 다 끝나면 원소가 남은 배열은 슬라이스로 붙여주기
if p1<n:
    c=c+a[p1:]
if p2<m:
    c=c+b[p2:]
for x in c:
    print(x, end=' ')
    
    
#¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨
#                 5. 수의 합 (1차원 배열)
#…………………………………………………………………………………………………………………………………………………………………………………………

n, m=map(int, input().split())
a=list(map(int, input().split()))
lt=0
rt=1
tot=a[0]
cnt=0
while True:
    if tot<m: # 아직 더 더해도됨
        if rt<n: 
            tot+=a[rt]
            rt+=1
        else:
            break
    elif tot==m: # 이제 과거원소버리고 lt +=1
        cnt+=1
        tot-=a[lt]
        lt+=1
    else: # 과거 원소버리기 너무
        tot-=a[lt]
        lt+=1
print(cnt)
